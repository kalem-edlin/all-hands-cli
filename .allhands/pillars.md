## Functional Pillars of This Harness

These are the load-bearing approaches that realize the First Principles in `principles.md`. Principles define **why**; pillars define **what** the harness structurally delivers.

### 1. Prompt-Driven Execution Loop
Prompt files are atomic units of work executed in tracked loops. Planned prompts deliver scoped tasks from planning; emergent prompts discover novel approaches via agentic hypothesis without engineer supervision. Alignment documents track summaries and decisions across iterations.

### 2. Knowledge Compounding
Everything feeds forward. Branch-scoped ephemeral artifacts — pain points, decisions, learnings — distill into persistent knowledge: solutions, memories, and domain documentation. Future initiatives benefit from all past work through structured retrieval at key planning and discovery points.

### 3. Approach Discoverability
Unified tooling makes knowledge and implementation patterns accessible. Embedded documentation search, semantic code analysis, and sub-agent delegation for scoped retrieval — both codebase-specific and external research. Reduces the cost of finding relevant context to near-zero.

### 4. Skills as Domain Practices
Codebase-specific domain knowledge tuned from execution experience. Not documentation but operational guidance — how to use tools, what patterns to follow, what to avoid. Explicitly accessible per domain. Refined through compounding cycles so future agents inherit hard-won learnings.

### 5. Context-Abstracted Tooling
CLI commands, MCP tools, and context handlers that process externally, withholding raw data from agent context windows. Oracle delegation for LLM-enabled deterministic tasks. Deterministic tools applied stochastically by agents via flow-suggested use cases.

### 6. Progressive Flow Architecture
Instruction sets disclosed progressively as agents need them. Flows reference flows, enabling diverse path-finding through predetermined decision trees. Agents work within scoped guidelines toward specific goals without seeing the full system at once.

### 7. Schema-Driven File Contracts
Single source of configuration for how workflow-critical files are structured. Validated on write, eliminating programmatic dependencies. Stochastic agents write to deterministic contracts across ephemeral and persisted files — one schema definition governs interpretation and authoring system-wide.

### 8. Initiative-Based Orchestration
Harness-managed workflows for milestone development, debugging, profiling, refactoring, and miscellaneous tasking. Engineering consultation captures desired state with minimal decision fatigue. TMUX orchestration, lifecycle management, observability (tracing), TUI capabilities, and coding agent hook injection for maximum engineer visibility and control. Templated message injection provides workflow-state-specific context to dependent agents.

### 9. Disposable Software & Variant Exploration
Open decisions become emergent implementations behind feature flags. Multiple solutions to the same problem enable quality engineering: engineers choose conventions, kill weak approaches, or refine into A/B tests for production end-user validation. Cheap software development with good guardrails and expectation setting during ideation.

### 10. Agentic Validation Tooling
Programmatic validation that decouples engineers from the implementation loop. Deterministic tooling (tests, migrations, type checks) provides quantitative pass/fail gating for CI/CD and regression prevention. Heuristic tooling (UI automation, log analysis, performance profiling) provides qualitative assessment via agent judgment. Both modes are first-class, discoverable, and compound through execution learnings — enabling engineers to focus on ideation and quality control while agents validate implementation against prepared expectations.
